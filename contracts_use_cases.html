<!DOCTYPE html>
<html>
<head>
    <title>Contracts 3.0 -- use cases</title>
    <style>

table, th, td{
  border: 1px solid black;
  padding: 5pt;
  border-spacing: 0;
  border-collapse: collapse;
}
    </style>
</head>
<body>

Editors: Ryan McDougall, Joshua Berne, Andrzej Krzemie&#324;ski, Timur Doumler

<h1>Contracts &mdash; use cases survey</h1>

<h2>Use cases &mdash; table</h2>
    
<table>
<tr><th>Code</th><th>As A</th><th>In Order To</th><th>I Want To</th><th>Priority</th></tr>
<tr><td><a href="#dev.decl.knowl">dev.decl.knowl</a></td>
    <td>Developer</td>
    <td>Make my reasoning explicit</td>
    <td>Be able to annotate my understanding of the program at any point in the program</td>
    <td></td></tr>

<tr><td></td>
  <td>Developer</td>
  <td>Reason explicitly</td>
  <td>Annotate my program anywhere in the code with my current understanding of its structure or execution</td>
  <td></td></tr>

<tr><td></td>
  <td>Developer</td>
  <td>Reason explicitly</td>
  <td>Express a spectrum of confidence in the information in my annotations, from “unsure” and asking for validation, to “sure” and asking for some action based on the information (such as “maybe”, “definitely”, “assume”)</td>
  <td></td></tr>

<tr><td></td>
  <td>Developer</td>
  <td>Reason explicitly</td>
  <td>Express a spectrum of importance of the information in my annotations, from "critical" (such as might bring the system down) to "minor" (such as might lead to a slower fallback) </td>
  <td></td></tr>

<tr><td></td>
  <td>Developer</td>
  <td>Reason explicitly</td>
  <td>Express a spectrum of expected cost at compile or runtime of my annotations, from "unrunnable" to "expensive" to "cheap"</td>
  <td></td></tr>

<tr><td></td>
  <td>Developer</td>
  <td>Reason about executions</td>
  <td>Have annotations affect the execution of my program in accordance with my expectations</td>
  <td></td></tr>

<tr><td></td>
  <td>Developer</td>
  <td>Reason about executions</td>
  <td>Ensure annotations do not substantially change the meaning of my program when enabled</td>
  <td></td></tr>

<tr><td></td>
  <td>Developer</td>
  <td>Reason about executions</td>
  <td>Have the effect of annotations on executions be user controllable (ie. decide whether “cheap” checks or “critical” terminates)</td>
  <td></td></tr>

<tr><td></td>
  <td>Developer</td>
  <td>Have readable annotations</td>
  <td>Have annotations with a succinct and elegant syntax</td>
  <td></td></tr>

<tr><td></td>
  <td>Developer</td>
  <td>Have readable annotations</td>
  <td>Have annotation keywords or names with intuitive, clear, and unambiguous meanings</td>
  <td></td></tr>

<tr><td></td>
  <td>Developer</td>
  <td>Have readable annotations</td>
  <td>Have my contract specification to be visually primary, and secondary information (syntax, hints, roles, levels, etc.) to not be distracting</td>
  <td></td></tr>

<tr><td></td>
  <td>Developer</td>
  <td>Adapt and progress with my project</td>
  <td>Be able to easily change my confidence, importance, or other properties of my annotations over time</td>
  <td></td></tr>

<tr><td></td>
  <td>Developer</td>
  <td>Interoperate with tools or persons</td>
  <td>A syntax that can both be parsed and can be reasoned about semantically</td>
  <td></td></tr>

<tr><td></td>
  <td>Developer</td>
  <td>Interoperate with tools or persons</td>
  <td>Expose annotations to tools that might leverage them (such as code linter, static analyzer, semantic prover, compiler sanitizer, binary analyzer, code reviewer, etc.)</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Developer</td>
  <td>Get up to speed</td>
  <td>Have annotations use familiar syntax</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Developer</td>
  <td>Get up to speed</td>
  <td>Have annotations use C++ syntax</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Developer</td>
  <td>Reuse code</td>
  <td>Have annotations use my custom types or functions</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Developer</td>
  <td>Have a single source of truth</td>
  <td>Use same source file for both code and annotations</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Developer</td>
  <td>Support modern features</td>
  <td>Minimize use of macros</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Developer</td>
  <td>Support modern features</td>
  <td>Be interoperable with modules</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Developer</td>
  <td>Support modern features</td>
  <td>Be interoperable with coroutines</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Developer</td>
  <td>Support modern features</td>
  <td>Be interoperable with concepts</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Developer</td>
  <td>Use STL in-contract</td>
  <td>Codify existing exposition-only STL requirements</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Developer</td>
  <td>Use Debugger</td>
  <td>Have runtime able to launch a debugger from an annotation if necessary</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Developer</td>
  <td>Use existing build modes</td>
  <td>Have annotations affect executions depending on my existing build modes (such as Debug or Release modes in VS)</td>
  <td></td></tr>

<tr><td></td>
  <td>C Developer</td>
  <td>Write contracts on my functions</td>
  <td>Specify contracts in a way standardizable as part of the C language</td>
  <td></td></tr>

<tr><td></td>
  <td>C Developer</td>
  <td>Write contracts on my functions</td>
  <td>Use contracts with macro-safe keywords that are reserved C names (i.e., _Pre, _Post, _Assert, etc.)</td>
  <td></td></tr>

<tr><td></td>
  <td>C Developer</td>
  <td>Write contracts on my functions</td>
  <td>Have a common violation handler for both violated C and C++ contracts</td>
  <td></td></tr>

<tr><td></td>
  <td>C Developer</td>
  <td>Write contracts on my functions</td>
  <td>Expose my contracts to C++ developers through 'extern "C"' declarations of my functions</td>
  <td></td></tr>

<tr><td></td>
  <td>C Developer</td>
  <td>Write contracts on my functions</td>
  <td>Make all contract semantics optional (so as not to change WG14-N2385 6.7.11 p2)</td>
  <td></td></tr>

<tr><td></td>
  <td>Mixed C/C++ Developer</td>
  <td>Maintain mixed code base</td>
  <td>Not lose contracts when crossing languages</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Communicate my interface to users</td>
  <td>Document the expected inputs and expected outputs on my interface</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Establish a contract</td>
  <td>Have validation inform me which output values are unexpected or invalid</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Establish a contract</td>
  <td>Have validation inform me which class invariants are violated</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Establish a contract</td>
  <td>Have validation inform user which input values are unexpected or invalid</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Establish a contract</td>
  <td>Have contracts specify their pre-conditions as logical predicates</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Establish a contract</td>
  <td>Have contracts specify their class invariants as logical predicates</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Establish a contract</td>
  <td>Have contracts specify their post-conditions as logical predicates</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Express predicates</td>
  <td>Make reference to either the values of my inputs, or other in-scope identifiers</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Establish a contract</td>
  <td>Make reference to the before and after values of in-out variables (such as passed by pointer or reference) in post-conditions</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Establish a contract</td>
  <td>Make reference to the before and after values of mutable class members (ie. <i>new_size = old_size+1</i> after push_back) in post-conditions</td>
  <td></td></tr>


<tr><td></td>
  <td>API Developer</td>
  <td>Establish a contract</td>
  <td>Make reference to the before and after values of global state (i.e., <i>now() >= old(now()) + sleep_time</i>) in post-conditions</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Extend contractual aspects</td>
  <td>Annotate operations as being exception safe</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Extend contractual aspects</td>
  <td>Annotate operations as being thread safe</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Extend contractual aspects</td>
  <td>Annotate operations as being atomic (ie. all or no changes become visible)</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Extend contractual aspects</td>
  <td>Annotate operations as real-time (ie. guaranteed to complete within a time frame)</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Extend contractual aspects</td>
  <td>Annotate operations as being deterministic (ie. same outputs for same inputs)</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Extend contractual aspects</td>
  <td>Annotate operations as functionally pure (ie. no side effects)</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Extend contractual aspects</td>
  <td>Annotate operations as having global side effects (ie. write to singleton, file, network, or database)</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Extend contractual aspects</td>
  <td>Annotate algorithmic complexity</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Express unrunnable contracts</td>
  <td>Be able to use a predicate that is not evaluated at runtime, because it might be unsafe to run or have stateful side effects</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Express unrunnable contracts</td>
  <td>Be able to use a predicate that doesn’t have a definition, because it hasn’t been written yet, or is infeasible to run</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Express uncheckable contracts</td>
  <td>Be able to use a predicate that is not evaluated, because it is simply a semantic placeholder for a tool</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Express uncheckable contracts</td>
  <td>Be able to use a predicate that cannot have a complete definition, because it is inexpressible in the language</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Establish responsibility boundaries</td>
  <td>Inform users which errors are the responsibility of the caller, and which are the callee</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Have contract as part of my interface</td>
  <td>Declare contract when I declare the function</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Keep my user interfaces clean and narrow</td>
  <td>Be able to access private implementation details of the class so I don’t have to widen public interface to declare predicates</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Keep my public interfaces clean and concise</td>
  <td>Place member function contract conditions outside the class definition (e.g., because my English-language contracts are more
    complete and more readable, or because the conditions might reference implementation details not relevant to readers).</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Keep my public interfaces clean and concise</td>
  <td>Place function contract conditions after the first declaration (e.g., because my English-language contracts are more complete and more readable, and my contract conditions are implementation details).</td>
  <td></td></tr>

<tr><td></td>
  <td>API Developer</td>
  <td>Move contract violation out of error handling</td>
  <td>Replace uses of error handling to express contract violation (ie. <i>operator[](size_t n) noexcept [[pre: n < size()]]</i>)</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ API Developer</td>
  <td>Express public class invariants</td>
  <td>Express a restriction on the public interface of a type that all callers of the type can depend upon: can mention only public members, and is checked on entry and exit from this type’s code</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ API Developer</td>
  <td>Express public class invariants</td>
  <td>Check invariants before and after every public method (when called from outside the type, not when one member function calls another)</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ API Developer</td>
  <td>Express public class invariants</td>
  <td>Check invariants before and after calling functions that are not part of this type (including virtual calls)</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ API Developer</td>
  <td>Express base class invariants</td>
  <td>Express a restriction on the protected interface of a type that derived types can depend upon: can mention only protected and private members, and is checked on entry and exit from this type’s code</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ API Developer</td>
  <td>Express base class invariants</td>
  <td>Check invariants on entry and exit of every protected method (when called from the derived type, not when one base member function calls another)</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ API Developer</td>
  <td>Express base class invariants</td>
  <td>Check invariants before and after every call to a virtual function (when calling to the derived type)</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ API Developer</td>
  <td>Express private class invariants</td>
  <td>Express an internal restriction on the private implementation of a type, can mention any member, and is checked on entry and exit from this type’s code</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ API Developer</td>
  <td>Express private class invariants</td>
  <td>Check invariants on entry and exit of every public method (when called from outside the type, not when one member function calls another)</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ API Developer</td>
  <td>Express private class invariants</td>
  <td>Check invariants before and after calling functions that are not part of this type (including virtual calls)</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ API Developer</td>
  <td>Test my classes</td>
  <td>For every member or friend function in my class, run my unit test framework with checking enabled for every assertion at the point where it is written, and check every postcondition at every non-exceptional exit, and test my class invariants on entry and exit from this type’s code</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ API Developer</td>
  <td>Use coroutines</td>
  <td>Define and check pre and post conditions as I would a regular function</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ API Developer</td>
  <td>Use coroutines</td>
  <td>Define and check invariants over all entry and exit points from a coroutine (to its awaiter or promise)</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Conform to a contract</td>
  <td>Be informed any time an interface’s contract is violated</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Conform to a contract</td>
  <td>Verify results from a call are expected output values</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Build multiple libraries</td>
  <td>Use contract-enabled header-only libraries</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Build multiple libraries</td>
  <td>Use contract-enabled binary libraries</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Build multiple libraries</td>
  <td>Only be required to manage a small, common set of build/link configurations</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Debug multiple libraries</td>
  <td>Enable checks only within a selected library</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Debug multiple libraries</td>
  <td>Enable checks on multiple libraries simultaneously</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Debug multiple call sites</td>
  <td>Enable checks only on selected call sites</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Correct failed checks</td>
  <td>Be informed what check failed, when, where, and how</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Correct failed checks</td>
  <td>Transmit check failure information in environment-specific ways (logs, email, special hardware traps, popup windows, blazing sirens, etc).</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Correct failed checks</td>
  <td>Install custom violation handler where I can inject custom logic to trap errors</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Unify violation handling</td>
  <td>Be able to override how library violations are handled in the combined software to point into my handling code</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Be independent of build environment</td>
  <td>Be able to define and override violation handler via source code</td>
  <td></td></tr>

<tr><td></td>
  <td>Integration Developer</td>
  <td>Minimize checking overhead</td>
  <td>Disable library postconditions, asserts, and invariants, without disabling library preconditions (assuming the library is tested and stable and my code is not)</td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Ensure the combined software is correct</td>
  <td>Turn checks on at build time</td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Ensure the combined software is correct</td>
  <td>Turn checks on at run time (pre, post, asset, invariant)</td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Ensure the combined software is correct</td>
  <td>Turn on any subset of individual (call site) checks on at build time </td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Ensure the combined software is correct</td>
  <td>Turn on any subset of individual (call site) checks on at run time</td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Ensure the combined software is correct</td>
  <td>Have an understandable way to identify different subsets of checks for various deployments</td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Ensure the combined software is correct</td>
  <td>Verify all annotations are globally consistent when integrated</td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Test final deliverable</td>
  <td>Turn off build time checking to remove checking overhead</td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Test final deliverable</td>
  <td>Turn off run time checking to remove checking overhead</td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Test final deliverable</td>
  <td>Turn on run time optimization to leverage annotation assumptions</td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Manage binary delivery</td>
  <td>Be able to use the same executable regardless of contract enforcement mode</td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Define “Code Under Test”</td>
  <td>Selectively enable checking for a set of functions which could name either an individual function or an overload set</td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Define “Code Under Test”</td>
  <td>Selectively enable checking for a set of types and all their members</td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Define “Code Under Test”</td>
  <td>Selectively enable checking for a set of types and all their transitively nested types and members</td>
  <td></td></tr>

<tr><td></td>
  <td>Integrated Software Provider</td>
  <td>Define “Code Under Test”</td>
  <td>Selectively enable checking for a translation unit or module and all (non transitive) types and functions within</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Library Developer</td>
  <td>Use templates</td>
  <td>Be able to ship header only library</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Library Developer</td>
  <td>Write classes</td>
  <td>Declare class invariants that all of my public functions need to maintain</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Library Developer</td>
  <td>Maintain a class hierarchy</td>
  <td>Ensure overriding methods have same or wider preconditions (see: Liskov substitution principle)</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Library Developer</td>
  <td>Maintain a class hierarchy</td>
  <td>Ensure overriding functions meet their base class postconditions when their base class preconditions are met (see: Liskov substitution principle)</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Library Developer</td>
  <td>Maintain a class hierarchy--</td>
  <td>Allow overriding functions to have narrower preconditions/wider postconditions if I want to</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Library Developer</td>
  <td>Enforce contracts in async code</td>
  <td>Express contracts on callbacks such as std::function, function pointers, or references to functions, lambdas, or function objects</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Library Developer</td>
  <td>Enforce contracts in exception safe code</td>
  <td>Express contracts on exceptional exit</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Library Developer</td>
  <td>Control the tradeoff between need for client recompilation and contract condition visibility</td>
  <td>Insulate contract conditions with the function definition</td>
  <td></td></tr>

<tr><td></td>
  <td>C++ Library Developer</td>
  <td>Control the tradeoff between need for client recompilation and contract condition visibility</td>
  <td>Insulate the function body but not the contract conditions (e.g., so static analysis tools can view the contract conditions without
    needing to process the function body) but still outside the class definition to avoid cluttering my public interface.
  <td></td></tr>

<tr><td></td>
  <td>C++ Library Developer</td>
  <td>Use contracts with variadic templates</td>
  <td>Allow predicate (fold) expansion</td>
  <td></td></tr>

<tr><td></td>
  <td>Library Provider</td>
  <td>Simplify maintenance</td>
  <td>Not require extra build steps to be documented</td>
  <td></td></tr>

<tr><td></td>
  <td>Library Provider</td>
  <td>Simplify maintenance</td>
  <td>Not have users complain about my product due to modifications of annotations resulting from their build configuration</td>
  <td></td></tr>

<tr><td></td>
  <td>Library Provider</td>
  <td>Support successful integration</td>
  <td>Not require extra build steps to be learned or performed</td>
  <td></td></tr>

<tr><td></td>
  <td>Library Provider</td>
  <td>Support successful integration</td>
  <td>Not have my users accidentally modify my careful annotations</td>
  <td></td></tr>

<tr><td></td>
  <td>Technical Architect</td>
  <td>Maintain quality of code base</td>
  <td>Express assertions in a way that does not rely on C macros (i.e., there is no valid technical reason for a programmer not to use the new way, including space, time, tooling, and usability/complexity reasons, compared to C’s assert macro)</td>
  <td></td></tr>

<tr><td></td>
  <td>Technical Architect</td>
  <td>Have a consistent and holistic contracts facility</td>
  <td>Specify preconditions/postconditions/assertions/invariants that express my expectations about the expected valid state of my program in the form of compilable boolean expressions, that can be checked statically or dynamically (as opposed to disjointed state where these features are factored into bits)</td>
  <td></td></tr>

<tr><td></td>
  <td>Hardware Architect</td>
  <td>Improve system-level performance</td>
  <td>Be able to design new hardware + optimizations, carefully dovetailed into one another, that depend on statically-unprovable facts being annotated in the code</td>
  <td></td></tr>

<tr><td></td>
  <td>Senior Developer</td>
  <td>Set an example</td>
  <td>Demonstrate best practice in defensive programming</td>
  <td></td></tr>

<tr><td></td>
  <td>Senior Developer</td>
  <td>Enforce code quality</td>
  <td>Discourage reliance on observable out-of-contract behavior by causing check failure to hard stop program or build</td>
  <td></td></tr>

<tr><td></td>
  <td>Senior Developer</td>
  <td>Enforce mature, finalized contracts</td>
  <td>Disable continuation on violation of stable and correct individual contracts</td>
  <td></td></tr>

<tr><td></td>
  <td>Senior Developer</td>
  <td>Enforce mature, finalized contracts</td>
  <td>Disable remapping of semantics on stable and correct individual contracts</td>
  <td></td></tr>

<tr><td></td>
  <td>Junior Developer</td>
  <td>Understand the API</td>
  <td>A uniform, fluent description of expected input values, expected output values, side effects, and all logical pre and post conditions</td>
  <td></td></tr>

<tr><td></td>
  <td>Junior Developer</td>
  <td>Understand the API</td>
  <td>Be informed when my usage is out of contract</td>
  <td></td></tr>

<tr><td></td>
  <td>Junior Developer</td>
  <td>Understand the program</td>
  <td>Know why my software is not building</td>
  <td></td></tr>

<tr><td></td>
  <td>Junior Developer</td>
  <td>Understand the program</td>
  <td>Know why my software is aborting</td>
  <td></td></tr>

<tr><td></td>
  <td>Junior Developer</td>
  <td>Understand the program</td>
  <td>Know why my software is out of contract</td>
  <td></td></tr>

<tr><td></td>
  <td>Junior Developer</td>
  <td>Understand the program</td>
  <td>Know that my program or build was halted due to contract violation</td>
  <td></td></tr>

<tr><td></td>
  <td>Junior Developer</td>
  <td>Understand the facility</td>
  <td>Be able to build a program with contracts after reasonably short tutorial </td>
  <td></td></tr>

<tr><td></td>
  <td>Junior Developer</td>
  <td>Understand the facility</td>
  <td>Have keywords with precise and unambiguous meanings</td>
  <td></td></tr>

<tr><td></td>
  <td>Junior Developer</td>
  <td>Improve my code</td>
  <td>Learn about software best practices by example</td>
  <td></td></tr>

<tr><td></td>
  <td>Agile Developer</td>
  <td>Iterate quickly</td>
  <td>Be able to write and modify contracts quickly without heavy boiler plate or up front cost</td>
  <td></td></tr>

<tr><td></td>
  <td>Agile Developer</td>
  <td>Safeguard evolving code</td>
  <td>Assert against conditions I am aware of but not finished handling fully</td>
  <td></td></tr>

<tr><td></td>
  <td>Business Developer</td>
  <td>Maintain confidentiality</td>
  <td>Not expose diagnostic information (source location, expressions, etc.) in the software I deliver to clients, even when I choose to have contracts enforced in the software I deliver</td>
  <td></td></tr>

<tr><td></td>
  <td>Performance Sensitive Developer</td>
  <td>Enable better performance</td>
  <td>Annotate my code with assumptions, likelihoods, or reachability information that a tool might not be able to deduce, but that I would be confident of</td>
  <td></td></tr>

<tr><td></td>
  <td>Performance Sensitive Developer</td>
  <td>Enable better performance</td>
  <td>Be able to give statically-unprovable facts to current and novel optimizers in terms of semantics my program does not depend-on but optimizers can’t figure out</td>
  <td></td></tr>

<tr><td></td>
  <td>Performance Sensitive Developer</td>
  <td>Enable better performance</td>
  <td>Accept responsibility for a malformed program that might result from eventually false information given by my annotations</td>
  <td></td></tr>

<tr><td></td>
  <td>Performance Sensitive Developer</td>
  <td>Have safety critical paths</td>
  <td>Isolate safety checks from performance annotations</td>
  <td></td></tr>

<tr><td></td>
  <td>Performance Sensitive Developer</td>
  <td>Have safety critical paths</td>
  <td>Retain checking even when optimizing with performance annotations</td>
  <td></td></tr>

<tr><td></td>
  <td>Quality Sensitive Developer</td>
  <td>Enable full checking</td>
  <td>Ensure all checks (pre, post, assert, invariant) are enabled</td>
  <td></td></tr>

<tr><td></td>
  <td>Quality Sensitive Developer</td>
  <td>Validate correctness</td>
  <td>Signify the predicates that should be verified by an analysis tool</td>
  <td></td></tr>

<tr><td></td>
  <td>Quality Sensitive Developer</td>
  <td>Manage multiple tools</td>
  <td>Signify subset of individual annotations to be consumed by a specific kind of verification tool</td>
  <td></td></tr>

<tr><td></td>
  <td>Quality Sensitive Developer</td>
  <td>Manage multiple tools</td>
  <td>Signify subset of individual annotations to be consumed by a specific instance of verification tool</td>
  <td></td></tr>

<tr><td></td>
  <td>Quality Sensitive Developer</td>
  <td>Manage multiple tools</td>
  <td>Use predicates that may not be understood by all instances of verification</td>
  <td></td></tr>

<tr><td></td>
  <td>Quality Sensitive Developer</td>
  <td>Manage multiple tools</td>
  <td>Use predicates that may not be understood by all kinds of verification</td>
  <td></td></tr>

<tr><td></td>
  <td>Quality Sensitive Developer</td>
  <td>Manage multiple tools</td>
  <td>Integrate the results of that static checker into how my program behaves in different ways: assume proven predicates, make unprovable predicates ill-formed, etc.</td>
  <td></td></tr>

<tr><td></td>
  <td>Quality Sensitive Developer</td>
  <td>Unit test predicates</td>
  <td>Override failure handler to trigger test failure instead of termination</td>
  <td></td></tr>

<tr><td></td>
  <td>Quality Sensitive Developer</td>
  <td>Unit test violation handlers</td>
  <td>Have a way to run handler on all combinations of available build modes</td>
  <td></td></tr>

<tr><td></td>
  <td>Quality Sensitive Developer</td>
  <td>Catch unexpected failure modes</td>
  <td>Log all predicate failure during fuzz testing</td>
  <td></td></tr>

<tr><td></td>
  <td>Critical Software Developer</td>
  <td>Have a verifiable release system</td>
  <td>Be able to control the configuration of contracts from a central point</td>
  <td></td></tr>

<tr><td></td>
  <td>Critical Software Developer</td>
  <td>Avoid undefined behavior</td>
  <td>Have contract violation at run-time always have well-defined behavior</td>
  <td></td></tr>

<tr><td></td>
  <td>Critical Software Developer</td>
  <td>Not have a faulty program lead to catastrophic failure</td>
  <td>Have access to a recovery path after contract violation</td>
  <td></td></tr>

<tr><td></td>
  <td>Critical Software Developer</td>
  <td>Not have a faulty program lead to catastrophic failure</td>
  <td>Be able to express error handling that may be redundant with contract checking</td>
  <td></td></tr>

<tr><td></td>
  <td>Critical Software Developer</td>
  <td>Not have a faulty program lead to catastrophic failure</td>
  <td>Not have contract build or run modes possibly be able to change or disable related error handling in any way</td>
  <td></td></tr>

<tr><td></td>
  <td>Critical Software Developer</td>
  <td>Be assured a critical violation uses a critical recovery path</td>
  <td>Couple recovery path to a specific contract within the source</td>
  <td></td></tr>

<tr><td></td>
  <td>Critical Software Developer</td>
  <td>Meet code coverage requirements</td>
  <td>Be able to run both success and failure branches in my test environment</td>
  <td></td></tr>

<tr><td></td>
  <td>Critical Software Developer</td>
  <td>Have redundant layering</td>
  <td>Be able to continue to run checks in a production environment (even after formal testing is complete)</td>
  <td></td></tr>

<tr><td></td>
  <td>Critical Software Developer</td>
  <td>Maximize coverage</td>
  <td>Be able to run checks in a production environment that are considered “cheap” compared to the expected cost of entering an invalid state</td>
  <td></td></tr>

<tr><td></td>
  <td>Critical Software Developer</td>
  <td>Avoid unexpected or undefined behavior</td>
  <td>Ensure checks will never be __assume’d/__builtin_assume’d by the compiler as if they were facts injected into the program (otherwise, if such an assumption ever failed, I would be running a different program that is not equivalent to the one I wrote; assumptions can expand the set of possible executions by injecting facts not otherwise knowable to the compiler)</td>
  <td></td></tr>

<tr><td></td>
  <td>Security Sensitive Developer</td>
  <td>Limit attack vectors</td>
  <td>Be unable to be insert code paths (such as violation handlers) at run time (ie. build time only)</td>
  <td></td></tr>

<tr><td></td>
  <td>Security Sensitive Developer</td>
  <td>Deliver a certified product</td>
  <td>Have build tool only link to a preapproved violation handler</td>
  <td></td></tr>

<tr><td></td>
  <td>User of Analysis Tools</td>
  <td>Improve runtime correctness</td>
  <td>Have runtime checks generated by the tool</td>
  <td></td></tr>

<tr><td></td>
  <td>User of Analysis Tools</td>
  <td>Improve runtime performance</td>
  <td>Have runtime optimizations generated by the tool</td>
  <td></td></tr>

<tr><td></td>
  <td>User of Analysis Tools</td>
  <td>Allow symbolic analysis</td>
  <td>Have symbolic proofs for soundness and consistency performed before compile time</td>
  <td></td></tr>

<tr><td></td>
  <td>User of Analysis Tools</td>
  <td>Allow code analysis</td>
  <td>Have code source, AST, or instruction inspection during compile time </td>
  <td></td></tr>

<tr><td></td>
  <td>User of Analysis Tools</td>
  <td>Allow binary analysis</td>
  <td>Have binary inspection after compile time</td>
  <td></td></tr>

<tr><td></td>
  <td>User of Analysis Tools</td>
  <td>Improve the quality of analysis</td>
  <td>Be able to hint to the analyzer information it may be unable to deduce from source code alone (ie. 5 / opaque_third_party(); [[ i != 0]])</td>
  <td></td></tr>

<tr><td></td>
  <td>Provider of Analysis Tools</td>
  <td>Extend my existing engine</td>
  <td>Be able to map pre-existing contract features in tools to a standardized language syntax</td>
  <td></td></tr>

<tr><td></td>
  <td>Teacher</td>
  <td>Demonstrate best practice</td>
  <td>Be able to express defensive programming, programming by contract, and test driven development to introductory students</td>
  <td></td></tr>

<tr><td></td>
  <td>Teacher</td>
  <td>Demonstrate best practice</td>
  <td>Not rely on custom libraries or proprietary extensions</td>
  <td></td></tr>

<tr><td></td>
  <td>Teacher</td>
  <td>Demonstrate best practice</td>
  <td>Demonstrate mock lifecycle by switching simple compiler flags to control which checks are enabled</td>
  <td></td></tr>

<tr><td></td>
  <td>Teacher</td>
  <td>Manage many students</td>
  <td>Have examples compilable by a standard compiler on any system</td>
  <td></td></tr>

<tr><td></td>
  <td>Teacher</td>
  <td>Manage many students</td>
  <td>Have examples that are easy to build without digression into build systems</td>
  <td></td></tr>

<tr><td></td>
  <td>Teacher</td>
  <td>Build layers of understanding</td>
  <td>Have simple explanation of assertions and their use to support simple programming tasks, including debugging erroneous programs.</td>
  <td></td></tr>

<tr><td></td>
  <td>Teacher</td>
  <td>Build layers of understanding</td>
  <td>Support the ability for advanced uses of contracts to be distributed across many different courses in a C++-focused computer science curriculum.</td>
  <td></td></tr>

<tr><td></td>
  <td>Compiler Developer</td>
  <td>Deliver best experience to my customers</td>
  <td>Maximize implementation freedom by limiting what is strictly required by the standard</td>
  <td></td></tr>

<tr><td></td>
  <td>Compiler Developer</td>
  <td>Deliver the best implementation</td>
  <td>Have a clear and simple specification that meets clear need</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Developer</td>
  <td>Debug complex issues</td>
  <td>Have composible and fine grained control over which checks are run, without requiring source code changes. Specifically the checks for only one function or some grouping of functions</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Developer</td>
  <td>Enable/Disable checking on critical/hot paths</td>
  <td>Control whether checks are run based on where they are being called from</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Modernize my code base</td>
  <td>Introduce standardized contracts to replace my macro-based contracts</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Modernize my code base</td>
  <td>Have my existing macro-based facilities interoperate smoothly with standardized contracts so I can do the migration gradually</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Introduce new contracts into an existing system</td>
  <td>Have failed individual checks from existing code optionally warn instead of hard stop</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Introduce new contracts into an existing system</td>
  <td>Have failed checks from a new library optionally warn instead of hard stop</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Introduce new parameters or invariants into a contracts based system</td>
  <td>Be able to include distinct clauses for each parameter or invariant with their own individual failure or build controls</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Introduce new elements into a contracts based system</td>
  <td>Have failed checks caused by a change in environment optionally warn instead of hard stop</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Introduce new elements into a contracts based system</td>
  <td>Have failed checks caused by a change in compiler optionally warn instead of hard stop</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Prevent regressions</td>
  <td>Have trusted contracts fail fast and hard stop</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Scale violation handling</td>
  <td>Be able to log violations in my organization specific format</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Allow simulation or post-mortem testing of known failure modes</td>
  <td>Optionally disable checking on a subset of individual annotations</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Allow simulation or post-mortem testing of known failure modes</td>
  <td>Optionally allow checking of a subset of individual annotations to fail and access its recovery path</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Allow simulation or post-mortem testing of known failure modes</td>
  <td>Optionally allow checking of a subset of individual annotations to fail and continue failing</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Manage performance cost</td>
  <td>Constrain the set of built time checks according to their performance overhead</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Manage performance cost</td>
  <td>Constrain the set of runtime checks according to their performance overhead</td>
  <td></td></tr>

<tr><td></td>
  <td>Large Codebase Owner</td>
  <td>Tune contract width in complex system</td>
  <td>Be able to narrow individual contract so it fails in testing not in production</td>
  <td></td></tr>

<tr><td></td>
  <td>Small Machine Developer</td>
  <td>Minimize executable footprint</td>
  <td>Remove all checking and diagnostic (such as source location) overhead entirely from the final binary</td>
  <td></td></tr>

<tr><td></td>
  <td>Small Machine Developer</td>
  <td>Minimize executable footprint</td>
  <td>Remove all logging and diagnostic (but not checking) overhead from the final binary</td>
  <td></td></tr>

<tr><td></td>
  <td>Small Machine Developer</td>
  <td>Minimize executable footprint</td>
  <td>Remove all but the most important diagnostic overhead from the final binary</td>
  <td></td></tr>

<tr><td></td>
  <td>Language Developer</td>
  <td>Interoperate with Contracts</td>
  <td>Have a clear way to understand how contracts will interact with the standard library</td>
  <td></td></tr>

<tr><td></td>
  <td>Language Developer</td>
  <td>Extend contracts beyond pre/post conditions on functions</td>
  <td>Be able to use contract-like syntax on past or present runtime checkable language features such as switches, pattern matching, etc. or what might happen on signed integer overflow, etc. This might allow configuration of trapping, logging, or assuming in other areas of language UB.</td>
  <td></td></tr>
</table>
    
<h2>Use cases &mdash; descriptions</h2>
 
<table> 
<tr><td><a name="dev.decl.knowl">dev.decl.knowl</a></td>
    <td>Be able to annotate my understanding of the state of ay variable at any point in the program, such as
	"upon function entry", "each time this instruction is executed".
	</td></tr>
<tr><td><a name="lib.rtc.preassert">lib.rtc.preassert</a></td>
    <td>Some function preconditiosn can be expressed as c++ expressions, but are runtime-expensive.
	However, if expressed inside function body ass assertions after some function logic has already been executed,
	the check whether the function has everything that is required is cheap. If I use an assertion like this,
	I want to annotate this assertion as being "precondition-like". The semantics would be that if it fails,
	it is reported as "caller's bug" rather than callee's bug, and if the build is configured
	to runtime-check only preconditions, such assertion should also be runitme-checked.
	</td></tr>
</table>

Rest is TBD...

</body>
</html>
